#!/bin/bash

# This bit of hilarious overkill is brought to you by boredom.

DOTFILES_ROOT=${1:-$HOME/dotfiles}

module_loaded() {
    for m in "${modules_loaded[@]}"; do
        if [ "$m" == "$1" ]; then
            debug "$1 already loaded"
            return 0
        fi
    done
    return 1
}

load_module() {
    module_loaded "$1" && return 0
    source "$1"
    if [ $? -eq 0 ]; then
        modules_loaded[${#modules_loaded[@]}]="$1"
        return 0
    fi
    return 1
}

run_depends() {
    debug "running depends $1"
    local DEPS=$(sed -ne 's/^###[[:space:]]*depends:[[:space:]]*\(.*\)/\1/' \
                      -e 't print' -e 'b end' -e ': print' -e 'p' \
                      -e ': end' "$1")
    local OLDIFS=$IFS
    IFS=$'\n'
    if [ -n "$DEPS" ]; then
        for d in $DEPS; do
            debug "eval '$d' for module $2"
            eval $d
            if [ $? -ne 0 ]; then
                debug "eval returned nonzero -- bailing from run_depends()"
                IFS=$OLDIFS
                return 1
            fi
        done
    fi
    IFS=$OLDIFS
    return 0
}

module() {
    local f="$DOTFILES_ROOT/modules.d/bash/$1.sh"
    if [ ! -f "$f" ]; then
        echo "No such module '$1'" >&2
        return 1
    fi
    run_depends "$f" "$1"
    if [ $? -ne 0 ]; then
        debug "Dependencies for $1 failed."
        return 1
    fi
    if ! load_module "$f"; then
        echo "Error loading module '$f'" >&2
        return 1 
    fi
    return $?
}

forget_modules() {
    unset modules_loaded
}

# lib has debug() in it, which we use...
if [ -f "$DOTFILES_ROOT/modules.d/bash/lib.sh" ]; then
    load_module "$DOTFILES_ROOT/modules.d/bash/lib.sh"
    if [ $? -ne 0 ]; then
        echo "Unable to load $f!" >&2
        return 1
    fi
fi

for f in $DOTFILES_ROOT/modules.d/bash/*.sh; do
    run_depends "$f"
    if [ $? -ne 0 ]; then
        debug "dependencies of $f failed"
        continue
    fi
    load_module "$f" || debug "nonzero return: $f"
done
